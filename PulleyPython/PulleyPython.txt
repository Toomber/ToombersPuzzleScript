title Pulley Python
author Toomber
homepage www.puzzlescript.net

key_repeat_interval 0.12
run_rules_on_level_start

========
OBJECTS
========

Background
GREEN(
11111
01111
11101
11111
10111)


Wall
BROWN DARKBROWN
00010
11111
01000
11111
00010

StickyBlock
Yellow

HeadUp
Blue Red Red
..0..
.000.
00000
00000
1...2

HeadDown
Blue Red Red
2...1
00000
00000
.000.
..0..

HeadRight
Blue Red Red
100..
.000.
.0000
.000.
200..

HeadLeft
Blue Red Red
..002
.000.
0000.
.000.
..001

HeadLooseUp
Blue Red White
..0..
.000.
00000
00000
.....

HeadLooseDown
Blue Red White
.....
00000
00000
.000.
..0..

HeadLooseRight
Blue Red White
.00..
.000.
.0000
.000.
.00..

HeadLooseLeft
Blue Red White
..00.
.000.
0000.
.000.
..00.


HeadWentUp
transparent
..0..
.000.
00000
.....
.....

HeadWentDown
transparent
.....
.....
00000
.000.
..0..

HeadWentRight
transparent
..0..
..00.
..000
..00.
..0..

HeadWentLeft
transparent
..0..
.00..
000..
.00..
..0..


LRibbonUp
red
00000
00000
.....
.....
.....


LRibbonDown
red
.....
.....
.....
00000
00000


LRibbonRight
red
...00
...00
...00
...00
...00


LRibbonLeft
red
00...
00...
00...
00...
00...



RRibbonUp
Red
00000
00000
.....
.....
.....


RRibbonDown
Red
.....
.....
.....
00000
00000


RRibbonRight
Red
...00
...00
...00
...00
...00


RRibbonLeft
Red
00...
00...
00...
00...
00...

TailEndLeft
transparent
00...
.....
.....
.....
.....

TailEndRight
transparent
.....
.....
00...
.....
.....

HeadLooseTemp
transparent

LeftTemp1
transparent

LeftTemp2
transparent

LeftDeleteEndPiece
transparent

RightTemp1 
transparent

RightTemp2 
transparent

RightDeleteEndPiece
transparent

LeftStuck
transparent

RightStuck
transparent


TempSwitchParity
orange

TempAlreadyReversedHeadWent
pink

TempReverseHeadWent
transparent


GroundColouring
#3d7a17

=======
LEGEND
=======

. = Background
# = Wall
H = HeadUp
S = StickyBlock
Head = HeadUp or HeadDown or HeadRight or HeadLeft
HeadLoose = HeadLooseUp or HeadLooseDown or HeadLooseRight or HeadLooseLeft
Player = Head or HeadLoose

Stuck = LeftStuck or RightStuck

HeadWent = HeadWentUp or HeadWentDown or HeadWentRight or HeadWentLeft
U = HeadWentUp
D = HeadWentDown
R = HeadWentRight
L = HeadWentLeft

TailEnd = TailEndLeft or TailEndRight

K = LRibbonLeft and RRibbonRight and HeadWentUp
X = LRibbonLeft and RRibbonRight and TailEndLeft and TailEndRight and HeadWentUp

RRibbon = RRibbonUp or RRibbonDown or RRibbonRight or RRibbonLeft
LRibbon = LRibbonUp or LRibbonDown or LRibbonRight or LRibbonLeft
Ribbon = RRibbon or LRibbon

notUpRibbon = LRibbonDown or RRibbonDown or LRibbonLeft or RRibbonLeft or LRibbonRight or RRibbonRight
notDownRibbon = LRibbonUp or RRibbonUp or LRibbonLeft or RRibbonLeft or LRibbonRight or RRibbonRight 
notRightRibbon = LRibbonUp or RRibbonUp or LRibbonDown or RRibbonDown or LRibbonLeft or RRibbonLeft 
notLeftRibbon = LRibbonUp or RRibbonUp or LRibbonDown or RRibbonDown or LRibbonRight or RRibbonRight 

Snake = Head or HeadWent

DeletionTemp = LeftTemp1 or LeftTemp2 or RightTemp1 or RightTemp2

Object = Player or Ribbon or Wall or StickyBlock


=======
SOUNDS
=======

================
COLLISIONLAYERS
================


Background
GroundColouring
HeadLooseTemp
LeftStuck
RightStuck
LeftTemp1
LeftTemp2
LeftDeleteEndPiece
RightTemp1
RightTemp2
RightDeleteEndPiece
TempSwitchParity
TempReverseHeadWent
TempAlreadyReversedHeadWent
HeadWent
RRibbonUp
RRibbonDown
RRibbonRight
RRibbonLeft
LRibbonUp
LRibbonDown
LRibbonRight
LRibbonLeft
Head, HeadLoose, Wall, StickyBlock


TailEndLeft
TailEndRight

======
RULES
======

[ > HeadLoose | StickyBlock] -> [ > HeadLoose | ] (temporary) 


[> Head | HeadWent] -> [ > Head | ]


[> Head | Ribbon] -> cancel 
[> Player | Wall] -> cancel
[> Player | StickyBlock] -> cancel

[ up HeadDown] -> cancel
[ down HeadUp] -> cancel
[ right HeadLeft] -> cancel
[ left HeadRight] -> cancel

(lay down string and record how much of each side created)
[up HeadUp no Ribbon] -> [LRibbonLeft RRibbonRight HeadWentUp LeftTemp1 RightTemp1 up HeadUp] 
[right HeadUp no Ribbon] -> [LRibbonLeft LRibbonUp HeadWentRight LeftTemp2 right HeadRight] 
[left HeadUp no Ribbon] -> [RRibbonRight RRibbonUp HeadWentLeft RightTemp2 left HeadLeft] 

[down HeadDown no Ribbon] -> [LRibbonRight RRibbonLeft HeadWentDown LeftTemp1 RightTemp1 down HeadDown] 
[right HeadDown no Ribbon] -> [RRibbonLeft RRibbonDown HeadWentRight RightTemp2 right HeadRight] 
[left HeadDown no Ribbon] -> [LRibbonRight LRibbonDown HeadWentLeft LeftTemp2 left HeadLeft] 

[right HeadRight no Ribbon] -> [LRibbonUp RRibbonDown HeadWentRight LeftTemp1 RightTemp1 right HeadRight] 
[up HeadRight no Ribbon] -> [RRibbonRight RRibbonDown HeadWentUp RightTemp2 up HeadUp] 
[down HeadRight no Ribbon] -> [LRibbonRight LRibbonUp HeadWentDown LeftTemp2 down HeadDown] 

[left HeadLeft no Ribbon] -> [LRibbonDown RRibbonUp HeadWentLeft LeftTemp1 RightTemp1 left HeadLeft] 
[up HeadLeft no Ribbon] -> [LRibbonDown LRibbonLeft HeadWentUp LeftTemp2 up HeadUp] 
[down HeadLeft no Ribbon] -> [RRibbonLeft RRibbonUp HeadWentDown RightTemp2 down HeadDown] 




(Rotate Loose Head)
[up HeadLoose] -> [up HeadLooseUp]
[down HeadLoose] -> [down HeadLooseDown]
[right HeadLoose] -> [right HeadLooseRight]
[left HeadLoose] -> [left HeadLooseLeft]


[Stuck] -> [] (clear stuck status)

(record if ribbon stuck on sticky blocks)
up [ LRibbonUp | StickyBlock ] -> [ LRibbonUp | StickyBlock LeftStuck]
down [ LRibbonDown | StickyBlock ] -> [ LRibbonDown | StickyBlock LeftStuck]
right [ LRibbonRight | StickyBlock ] -> [ LRibbonRight | StickyBlock LeftStuck]
left [ LRibbonLeft | StickyBlock ] -> [ LRibbonLeft | StickyBlock LeftStuck]

up [ RRibbonUp | StickyBlock ] -> [ RRibbonUp | StickyBlock RightStuck]
down [ RRibbonDown | StickyBlock ] -> [ RRibbonDown | StickyBlock RightStuck]
right [ RRibbonRight | StickyBlock ] -> [ RRibbonRight | StickyBlock RightStuck]
left [ RRibbonLeft | StickyBlock ] -> [ RRibbonLeft | StickyBlock RightStuck]


[LeftStuck][RightStuck] -> cancel

(switch temp objects to other side if that side is stuck)
[LeftStuck][LeftTemp1 RightTemp1] -> [LeftStuck][[RightTemp2]
[LeftStuck][LeftTemp2] -> [LeftStuck][[RightTemp2]

[RightStuck][LeftTemp1 RightTemp1] -> [RightStuck][[LeftTemp2]
[RightStuck][RightTemp2] -> [RightStuck][[LeftTemp2]




(loop through all tail end configurations and delete strings if there are temp objects)
startloop

[LeftTemp2] -> [LeftTemp2 LeftDeleteEndPiece]
[RightTemp2] -> [RightTemp2 RightDeleteEndPiece]

[LeftTemp1] -> [LeftDeleteEndPiece]
[RightTemp1] -> [RightDeleteEndPiece]


[LeftDeleteEndPiece][TailEndLeft HeadWentUp LRibbonDown] -> [][TailEndLeft HeadWentUp]
[LeftDeleteEndPiece][TailEndLeft HeadWentUp LRibbonLeft] -> [][TailEndLeft HeadWentUp]

[LeftDeleteEndPiece][TailEndLeft HeadWentDown LRibbonUp] -> [][TailEndLeft HeadWentDown]
[LeftDeleteEndPiece][TailEndLeft HeadWentDown LRibbonRight] -> [][TailEndLeft HeadWentDown]

[LeftDeleteEndPiece][TailEndLeft HeadWentRight LRibbonLeft] -> [][TailEndLeft HeadWentRight]
[LeftDeleteEndPiece][TailEndLeft HeadWentRight LRibbonUp] -> [][TailEndLeft HeadWentRight]

[LeftDeleteEndPiece][TailEndLeft HeadWentLeft LRibbonRight] -> [][TailEndLeft HeadWentLeft]
[LeftDeleteEndPiece][TailEndLeft HeadWentLeft LRibbonDown] -> [][TailEndLeft HeadWentLeft]



[RightDeleteEndPiece][TailEndRight HeadWentUp RRibbonDown] -> [][TailEndRight HeadWentUp]
[RightDeleteEndPiece][TailEndRight HeadWentUp RRibbonRight] -> [][TailEndRight HeadWentUp]

[RightDeleteEndPiece][TailEndRight HeadWentDown RRibbonUp] -> [][TailEndRight HeadWentDown]
[RightDeleteEndPiece][TailEndRight HeadWentDown RRibbonLeft] -> [][TailEndRight HeadWentDown]

[RightDeleteEndPiece][TailEndRight HeadWentRight RRibbonLeft] -> [][TailEndRight HeadWentRight]
[RightDeleteEndPiece][TailEndRight HeadWentRight RRibbonDown] -> [][TailEndRight HeadWentRight]

[RightDeleteEndPiece][TailEndRight HeadWentLeft RRibbonRight] -> [][TailEndRight HeadWentLeft]
[RightDeleteEndPiece][TailEndRight HeadWentLeft RRibbonUp] -> [][TailEndRight HeadWentLeft]


(move the end of tail markers up if there are no string pieces in the square)
up [HeadWentUp TailEndLeft no LRibbon | ][Head] -> [HeadWentUp | TailEndLeft][Head]
down [HeadWentDown TailEndLeft no LRibbon | ][Head] -> [HeadWentDown | TailEndLeft][Head]
right [HeadWentRight TailEndLeft no LRibbon | ][Head] -> [HeadWentRight | TailEndLeft][Head]
left [HeadWentLeft TailEndLeft no LRibbon | ][Head] -> [HeadWentLeft | TailEndLeft][Head]

up [HeadWentUp TailEndRight no RRibbon | ][Head] -> [HeadWentUp | TailEndRight][Head]
down [HeadWentDown TailEndRight no RRibbon | ][Head] -> [HeadWentDown | TailEndRight][Head]
right [HeadWentRight TailEndRight no RRibbon | ][Head] -> [HeadWentRight | TailEndRight][Head]
left [HeadWentLeft TailEndRight no RRibbon | ][Head] -> [HeadWentLeft | TailEndRight][Head]

[LeftTemp2] -> [LeftTemp1]
[RightTemp2] -> [RightTemp1]

endloop

(clean up extra pieces made when stuck and turning to create 2 pieces when 
there's only one to delete from other side)

[LeftDeleteEndPiece][Head HeadWentUp RRibbonRight] -> [][Head HeadWentUp]
[LeftDeleteEndPiece][Head HeadWentDown RRibbonLeft] -> [][Head HeadWentDown]
[LeftDeleteEndPiece][Head HeadWentRight RRibbonDown] -> [][Head HeadWentRight]
[LeftDeleteEndPiece][Head HeadWentLeft RRibbonUp] -> [][Head HeadWentLeft]

[RightDeleteEndPiece][Head HeadWentUp LRibbonLeft] -> [][Head HeadWentUp]
[RightDeleteEndPiece][Head HeadWentDown LRibbonRight] -> [][Head HeadWentDown]
[RightDeleteEndPiece][Head HeadWentRight LRibbonUp] -> [][Head HeadWentRight]
[RightDeleteEndPiece][Head HeadWentLeft LRibbonDown] -> [][Head HeadWentLeft]



(move end markers back to where the head is, to address overshoot when separating from ribbon)

up [HeadUp | TailEnd no Ribbon] -> [ HeadUp TailEnd| ] 
down [HeadDown | TailEnd no Ribbon] -> [ HeadDown TailEnd| ] 
right [HeadRight | TailEnd no Ribbon] -> [ HeadRight TailEnd| ] 
left [HeadLeft | TailEnd no Ribbon] -> [ HeadLeft TailEnd| ] 


(-----------Connect Head------------)

[ > HeadLoose | Ribbon | Object ] -> cancel


[ > HeadLooseUp | notUpRibbon] -> cancel
[ > HeadLooseDown | notDownRibbon] -> cancel
[ > HeadLooseRight | notRightRibbon] -> cancel
[ > HeadLooseLeft | notLeftRibbon] -> cancel

[ > HeadLoose | TailEnd ] -> cancel (might want to change this)
[ > HeadLoose | ribbon ] -> [ | HeadLoose TempSwitchParity]


(propagate parity switching)

up [ HeadWentUp TempSwitchParity no TailEnd | ] -> [HeadWentUp TempSwitchParity | TempSwitchParity]
+down [ HeadWentDown TempSwitchParity no TailEnd | ] -> [HeadWentDown TempSwitchParity | TempSwitchParity]
+right [ HeadWentRight TempSwitchParity no TailEnd | ] -> [HeadWentRight TempSwitchParity | TempSwitchParity]
+left [ HeadWentLeft TempSwitchParity no TailEnd | ] -> [HeadWentLeft TempSwitchParity | TempSwitchParity]


(reverse the HeadWent direction)

[TailEnd TempSwitchParity] -> [TailEnd TempSwitchParity TempReverseHeadWent]

up [TempReverseHeadWent HeadWent | HeadWentDown no TempAlreadyReversedHeadWent TempSwitchParity] -> [ TempAlreadyReversedHeadWent HeadWentUp | TempReverseHeadWent HeadWentDown TempSwitchParity ]
+down [TempReverseHeadWent HeadWent | HeadWentUp no TempAlreadyReversedHeadWent TempSwitchParity] -> [ TempAlreadyReversedHeadWent HeadWentDown | TempReverseHeadWent HeadWentUp TempSwitchParity]
+right [TempReverseHeadWent HeadWent | HeadWentLeft no TempAlreadyReversedHeadWent TempSwitchParity] -> [ TempAlreadyReversedHeadWent HeadWentRight | TempReverseHeadWent HeadWentLeft TempSwitchParity]
+left [TempReverseHeadWent HeadWent | HeadWentRight no TempAlreadyReversedHeadWent TempSwitchParity] -> [ TempAlreadyReversedHeadWent HeadWentLeft | TempReverseHeadWent HeadWentRight TempSwitchParity]

[TempAlreadyReversedHeadWent] -> []
[TempReverseHeadWent] -> []

(switch ribbon parity)
[TailEndRight TempSwitchParity][LRibbonUp TempSwitchParity] -> [TailEndRight TempSwitchParity][RRibbonUp TempSwitchParity] 
+[TailEndRight TempSwitchParity][LRibbonDown TempSwitchParity] -> [TailEndRight TempSwitchParity][RRibbonDown TempSwitchParity] 
+[TailEndRight TempSwitchParity][LRibbonRight TempSwitchParity] -> [TailEndRight TempSwitchParity][RRibbonRight TempSwitchParity] 
+[TailEndRight TempSwitchParity][LRibbonLeft TempSwitchParity] -> [TailEndRight TempSwitchParity][RRibbonLeft TempSwitchParity] 

[TailEndLeft TempSwitchParity][RRibbonUp TempSwitchParity] -> [TailEndLeft TempSwitchParity][LRibbonUp TempSwitchParity] 
+[TailEndLeft TempSwitchParity][RRibbonDown TempSwitchParity] -> [TailEndLeft TempSwitchParity][LRibbonDown TempSwitchParity] 
+[TailEndLeft TempSwitchParity][RRibbonRight TempSwitchParity] -> [TailEndLeft TempSwitchParity][LRibbonRight TempSwitchParity] 
+[TailEndLeft TempSwitchParity][RRibbonLeft TempSwitchParity] -> [TailEndLEft TempSwitchParity][LRibbonLeft TempSwitchParity] 



(move loose head past ribbon)
up [TempSwitchParity][ HeadLooseUp | ] -> [TempSwitchParity][HeadWentUp | HeadUp]
down [TempSwitchParity][ HeadLooseDown | ] -> [TempSwitchParity][HeadWentDown | HeadDown]
right [TempSwitchParity][ HeadLooseRight | ] -> [TempSwitchParity][HeadWentRight | HeadRight]
left [TempSwitchParity][ HeadLooseLeft | ] -> [TempSwitchParity][HeadWentLeft | HeadLeft]

[TempSwitchParity] -> []

(----------------------------------)

(Disconnect Head)
[Head] -> [Head HeadLooseTemp]
[HeadLooseTemp][ LRibbon ][ RRibbon] -> [][ LRibbon ][ RRibbon ] (check if both types of ribbon still exist)
[HeadLooseTemp moving HeadUp] -> [moving HeadLooseUp]
[HeadLooseTemp moving HeadDown] -> [moving HeadLooseDown]
[HeadLooseTemp moving HeadLeft] -> [moving HeadLooseLeft]
[HeadLooseTemp moving HeadRight] -> [moving HeadLooseRight]


(colour ground)
[GroundColouring]->[]
[Ribbon] -> [Ribbon GroundColouring]

==============
WINCONDITIONS
==============


=======
LEVELS
=======

#################
#...............#
#..s............#
#...............#
#...............#
#..s...........h#
#..............k#
#.....s........k#
#..............k#
#..............k#
#..............k#
#..............k#
#......s.......k#
#.s.........s..k#
#..............x#
#...............#
#################
